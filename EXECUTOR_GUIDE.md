# COLT Task Executor Guide

## Overview

The COLT Task Executor takes LLM-generated action plans and executes them in a real browser using Playwright. It's the "hands" that carry out the "brain's" instructions.

## Architecture

```
┌─────────────────────────────────────────────────────┐
│              Action Plan (JSON)                      │
│  Generated by LLM Task Planner                      │
└──────────────────┬──────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────┐
│            Task Executor                             │
│  • Loads plan from JSON                             │
│  • Initializes Playwright browser                   │
│  • Executes steps sequentially                      │
│  • Verifies outcomes                                │
│  • Captures screenshots                             │
│  • Generates execution report                       │
└──────────────────┬──────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────┐
│          Action Handlers                             │
│  • navigate - Go to URLs                            │
│  • click - Click elements                           │
│  • fill_form - Fill form fields                     │
│  • submit - Submit forms                            │
│  • wait - Wait for conditions                       │
│  • verify - Verify outcomes                         │
│  • type_text - Type with delays                     │
└──────────────────┬──────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────┐
│             Verifier                                 │
│  • Checks expected outcomes                         │
│  • Validates page state                             │
│  • Reports success/failure                          │
└─────────────────────────────────────────────────────┘
```

## Components

### 1. TaskExecutor (`src/executor/task_executor.py`)

Main orchestrator that:
- Initializes Playwright browser
- Loads action plans from JSON
- Executes each step sequentially
- Captures before/after screenshots
- Verifies outcomes
- Handles errors gracefully
- Saves execution reports

**Key Methods:**
- `initialize()` - Set up browser
- `execute_plan(plan)` - Execute a complete plan
- `cleanup()` - Clean up resources
- `load_plan(path)` - Load plan from JSON file

### 2. ActionHandlers (`src/executor/action_handlers.py`)

Handles execution of different action types:

#### **navigate**
Navigate to a URL
```python
{
    "action_type": "navigate",
    "target": {
        "url": "http://localhost:3000/contact"
    }
}
```

#### **click**
Click an element by selector or text
```python
{
    "action_type": "click",
    "target": {
        "selector": "button[type='submit']",
        # OR
        "text": "Submit"
    }
}
```

#### **fill_form**
Fill form fields
```python
{
    "action_type": "fill_form",
    "target": {
        "form_data": {
            "name": "Test User",
            "email": "test@example.com",
            "message": "Hello"
        }
    }
}
```

#### **submit**
Submit a form
```python
{
    "action_type": "submit",
    "target": {
        "selector": "button[type='submit']"
    }
}
```

#### **wait**
Wait for duration or condition
```python
{
    "action_type": "wait",
    "target": {
        "duration": 2000  # milliseconds
        # OR
        "selector": ".success-message",
        "condition": "visible"
    }
}
```

#### **verify**
Verify conditions
```python
{
    "action_type": "verify",
    "target": {
        "url_contains": "success",
        "selector": ".confirmation",
        "text": "Thank you"
    }
}
```

#### **type_text**
Type text with keystroke delays
```python
{
    "action_type": "type_text",
    "target": {
        "selector": "input[name='search']",
        "text": "search query",
        "delay": 50  # ms between keystrokes
    }
}
```

### 3. Verifier (`src/executor/verification.py`)

Verifies expected outcomes after each step:
- Checks URLs
- Validates element presence
- Searches for success/error messages
- Verifies page state
- Reports warnings and errors

## Usage

### Installation

Already installed! The executor uses the same dependencies as the explorer (Playwright).

### Basic Usage

#### 1. Execute a Plan

```bash
# Execute a plan with visible browser
python execute_plan.py output/generated_plans/plan_submit_form.json

# Execute in headless mode (no browser window)
python execute_plan.py plan.json --headless

# Show plan before executing
python execute_plan.py plan.json --show-plan

# Skip confirmation
python execute_plan.py plan.json --yes
```

#### 2. Programmatic Usage

```python
import asyncio
from src.executor.task_executor import TaskExecutor

async def run_plan():
    executor = TaskExecutor(headless=False, slow_mo=500)

    try:
        # Initialize
        await executor.initialize()

        # Load plan
        plan = executor.load_plan("output/generated_plans/plan_submit_form.json")

        # Execute
        result = await executor.execute_plan(plan)

        # Print summary
        executor.print_execution_summary(result)

        return result['success']

    finally:
        await executor.cleanup()

# Run
success = asyncio.run(run_plan())
```

### Complete Workflow

```bash
# 1. Explore your app
python explorer.py

# 2. Plan a task
python planner_cli.py "Submit the contact form"

# 3. Execute the plan
python execute_plan.py output/generated_plans/plan_submit_the_contact_form.json --show-plan
```

## Configuration

You can customize executor behavior:

```python
executor = TaskExecutor(
    headless=False,        # Show browser window
    slow_mo=500,          # Slow down actions (ms)
    timeout=30000,        # Action timeout (ms)
    screenshot_dir="output/execution_screenshots"
)
```

## Output

### Screenshots

For each step, the executor captures:
- `step_01_before.png` - Before action
- `step_01_after.png` - After action
- `step_01_error.png` - On error

Saved in `output/execution_screenshots/`

### Execution Reports

JSON reports saved in `output/execution_reports/`:

```json
{
  "plan": { /* Original plan */ },
  "execution": {
    "task": "Submit contact form",
    "success": true,
    "steps_executed": 4,
    "steps_total": 4,
    "step_results": [
      {
        "step_number": 1,
        "action_type": "navigate",
        "success": true,
        "action_result": { /* Action details */ },
        "verification": { /* Verification results */ },
        "screenshot_before": "path/to/screenshot.png",
        "screenshot_after": "path/to/screenshot.png"
      }
    ],
    "errors": []
  }
}
```

## Error Handling

The executor handles errors gracefully:

### Non-Fatal Errors
- Element not found (retries with alternative selectors)
- Timeout waiting for element
- Form field not fillable
- Continues to next step with warning

### Fatal Errors
- Browser crash
- Invalid action type
- Critical JavaScript error
- Stops execution immediately

### Error Recovery

The executor tries multiple strategies:
1. **Element Selection**: Tries name, id, label, placeholder
2. **Wait Strategies**: Waits for visibility, then clickability
3. **Scroll Into View**: Auto-scrolls to elements
4. **Form Detection**: Handles text, select, checkbox, radio, textarea

## Verification

Each step is verified:

### Navigation Verification
- URL matches expected
- HTTP status 200-399
- Page loaded successfully

### Click Verification
- URL changed (if navigation expected)
- Modal appeared
- Content changed

### Form Fill Verification
- All fields filled
- No errors
- Values set correctly

### Submit Verification
- Form submitted (navigation or AJAX)
- Success message appeared
- No error messages

## Advanced Features

### Custom Verification

Add verification logic to your plan:

```json
{
  "step_number": 4,
  "action_type": "verify",
  "description": "Verify form submission",
  "target": {
    "url_contains": "/success",
    "text": "Thank you for submitting",
    "selector": ".success-message"
  },
  "expected_outcome": "Success page displayed",
  "verification": "Check for confirmation message"
}
```

### Wait for Dynamic Content

```json
{
  "step_number": 2,
  "action_type": "wait",
  "description": "Wait for modal to appear",
  "target": {
    "selector": ".modal",
    "condition": "visible"
  }
}
```

### Type with Delays (for React/Vue apps)

```json
{
  "step_number": 3,
  "action_type": "type_text",
  "description": "Type slowly for React onChange",
  "target": {
    "selector": "input[name='search']",
    "text": "laptop",
    "delay": 100
  }
}
```

## CLI Options

```bash
python execute_plan.py [OPTIONS] PLAN_FILE

Options:
  --headless            Run in headless mode (no browser window)
  --slow-mo N           Slow down by N milliseconds
  --timeout N           Timeout in milliseconds (default: 30000)
  --screenshot-dir DIR  Screenshot directory
  --show-plan           Show plan before execution
  --yes, -y             Skip confirmation
  --no-save             Don't save execution report
```

## Testing

Run the executor test suite:

```bash
python test_executor.py
```

Tests include:
- Initialization
- Plan loading
- Action handlers (navigate, click, fill, verify, wait)
- Verification system
- Full plan execution

## Troubleshooting

### "Element not found"
- Check selector is correct
- Element might not be visible yet (add wait step)
- Element might be in iframe
- Try using text instead of selector

### "Timeout waiting for element"
- Increase timeout with `--timeout` flag
- Add explicit wait step before action
- Check if element requires scroll

### "Form field not fillable"
- Field might be disabled or readonly
- Field might require specific format
- Try using `type_text` instead of `fill_form`

### "Navigation didn't occur"
- Form might be AJAX (not a problem)
- Click might trigger modal instead
- Check if JavaScript is blocking navigation

### "Verification failed"
- Check expected outcomes are realistic
- Success messages might appear slowly (add wait)
- Text might be in different case
- Element might have different selector

## Best Practices

### 1. Add Wait Steps
Between actions for dynamic content:
```json
{"action_type": "click", ...},
{"action_type": "wait", "target": {"duration": 1000}},
{"action_type": "verify", ...}
```

### 2. Verify Each Step
Don't assume actions succeed:
```json
{"action_type": "fill_form", ...},
{"action_type": "verify", "target": {"selector": "input[name='email'][value]"}},
{"action_type": "submit", ...}
```

### 3. Use Specific Selectors
Avoid generic selectors like `button`, use:
- `button[type='submit']`
- `button#submit-btn`
- `button.primary-action`

### 4. Handle Errors Gracefully
Plans should include verification:
```json
{
  "action_type": "verify",
  "target": {
    "text": "Success",
    "selector": ".error-message"
  }
}
```

### 5. Start Simple
Test with simple plans before complex ones:
1. Navigate only
2. Navigate + verify
3. Navigate + click
4. Full workflow

## Examples

### Example 1: Simple Navigation

```json
{
  "task_description": "Navigate to about page",
  "steps": [
    {
      "step_number": 1,
      "action_type": "navigate",
      "description": "Go to homepage",
      "target": {"url": "http://localhost:3000"},
      "expected_outcome": "Homepage loads",
      "verification": "Check URL"
    },
    {
      "step_number": 2,
      "action_type": "click",
      "description": "Click About link",
      "target": {"text": "About"},
      "expected_outcome": "Navigate to about page",
      "verification": "URL contains /about"
    },
    {
      "step_number": 3,
      "action_type": "verify",
      "description": "Verify about page",
      "target": {"text": "About Us"},
      "expected_outcome": "About page displayed",
      "verification": "Page title visible"
    }
  ],
  "expected_result": "Successfully navigated to about page",
  "confidence": 0.95
}
```

### Example 2: Form Submission

```json
{
  "task_description": "Submit contact form",
  "steps": [
    {
      "step_number": 1,
      "action_type": "navigate",
      "target": {"url": "http://localhost:3000/contact"}
    },
    {
      "step_number": 2,
      "action_type": "fill_form",
      "target": {
        "form_data": {
          "name": "Test User",
          "email": "test@example.com",
          "message": "This is a test"
        }
      }
    },
    {
      "step_number": 3,
      "action_type": "submit",
      "target": {"selector": "button[type='submit']"}
    },
    {
      "step_number": 4,
      "action_type": "verify",
      "target": {
        "text": "Thank you",
        "url_contains": "success"
      }
    }
  ],
  "expected_result": "Form submitted successfully",
  "confidence": 0.9
}
```

## Future Enhancements

Planned features:
- **Retry logic** - Auto-retry failed steps
- **Parallel execution** - Run multiple plans
- **Conditional steps** - If/else logic
- **Variable substitution** - Dynamic values
- **File uploads** - Handle file inputs
- **iframe handling** - Work with embedded frames
- **Download verification** - Check downloads
- **API verification** - Verify network calls

## License

MIT License - Same as COLT project
